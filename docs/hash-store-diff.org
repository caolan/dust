A table to help me think through each case the hash tree diff algorithm will enounter.

| test? | key                | leaf L | leaf R | hash | notes                                                                                                                | code | result      | next                                                              | advance |
|-------+--------------------+--------+--------+------+----------------------------------------------------------------------------------------------------------------------+------+-------------+-------------------------------------------------------------------+---------|
| Y     | L is null          | -      | Y      | -    | all remaining remote children are not in local store                                                                 | a(R) | new R       | -                                                                 | R       |
| Y     | L is null          | -      | N      | -    | all remaining remote children are not in local store                                                                 | b(R) | -           | request leaf hashes of R to mark as new                           | R       |
| Y     | R is null          | Y      | -      | -    | all remaining local children are not in remote store                                                                 | a(L) | missing L   | -                                                                 | L       |
| Y     | R is null          | N      | -      | -    | all remaining local children are not in remote store                                                                 | b(L) | -           | request leaf hashes of L to mark as missing                       | L       |
| Y     | L is prefix of R   | Y      | -      | -    | L is missing from remote                                                                                             | a(L) | missing L   | -                                                                 | L       |
| Y     | L is prefix of R   | N      | Y      | -    | L might contain R                                                                                                    | c(L) | -           | compare leaf hashes of L to the single hash of R in lazy-seq      | L, R    |
| Y     | L is prefix of R   | N      | N      | -    | L might contain R, child nodes of L which are not R are missing from remote, if prefix or equal to R we need to diff | d(L) | -           | compare children of L to a sequence containing the single child R | L, R    |
| Y     | R is prefix of L   | -      | Y      | -    | R is new to local                                                                                                    | a(R) | new R       | -                                                                 | R       |
| Y     | R is prefix of L   | Y      | N      | -    | R might contain L                                                                                                    | c(R) | -           | compare leaf hashes of R to the single hash of L in lazy-seq      | L, R    |
| Y     | R is prefix of L   | N      | N      | -    | R might contain L, child nodes of R which are not L are new to local, if prefix or equal to L we need to diff        | d(R) | -           | compare children of R to a sequence containing the single child L | L, R    |
| Y     | L == R             | Y      | Y      | same | same key + hash, skip                                                                                                | e    | -           | -                                                                 | L, R    |
| Y     | L == R             | Y      | Y      | diff | same key, different hash                                                                                             | f    | different L | -                                                                 | L, R    |
| Y     | L == R             | Y      | N      | -    | equivalent to R prefix of L (with L being empty key) - R might contain L                                             | c(R) | -           | compare leaf hashes of R to the single hash of L in lazy-seq      | L, R    |
| Y     | L == R             | N      | Y      | -    | equivalent to L prefix of R (with R being empty key) - L might contain R                                             | c(L) | -           | compare leaf hashes of L to the single hash of R in lazy-seq      | L, R    |
| Y     | L == R             | N      | N      | same | same prefix + hash, skip                                                                                             | e    | -           | -                                                                 | L, R    |
| Y     | L == R             | N      | N      | diff | same prefix, different hash                                                                                          | g    | -           | compare children of L to children of R                            | L, R    |
| Y     | L < R (not prefix) | Y      | -      | -    | same as when R is null                                                                                               | a(L) | missing L   | -                                                                 | L       |
| Y     | L < R (not prefix) | N      | -      | -    | same as when R is null                                                                                               | b(L) | -           | request leaf hashes of L to mark as missing                       | L       |
| Y     | L > R (not prefix) | -      | Y      | -    | same as when L is null                                                                                               | a(R) | new R       | -                                                                 | R       |
| Y     | L > R (not prefix) | -      | N      | -    | same as when L is null                                                                                               | b(R) | -           | request leaf hashes of R to mark as new                           | R       |
