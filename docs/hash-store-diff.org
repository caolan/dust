A table to help me think through each case the hash tree diff algorithm will enounter.

| key                | leaf L | leaf R | hash | notes                                                                                                                | result      | next                                                              | advance | test? |
|--------------------+--------+--------+------+----------------------------------------------------------------------------------------------------------------------+-------------+-------------------------------------------------------------------+---------+-------|
| L is null          | -      | Y      | -    | all remaining remote children are not in local store                                                                 | new R       | -                                                                 | R       | Y     |
| L is null          | -      | N      | -    | all remaining remote children are not in local store                                                                 | -           | request leaf hashes of R to mark as new                           | R       | Y     |
| R is null          | Y      | -      | -    | all remaining local children are not in remote store                                                                 | missing L   | -                                                                 | L       | Y     |
| R is null          | N      | -      | -    | all remaining local children are not in remote store                                                                 | -           | request leaf hashes of L to mark as missing                       | L       | Y     |
| L is prefix of R   | Y      | -      | -    | L is missing from remote                                                                                             | missing L   | -                                                                 | L       | Y     |
| L is prefix of R   | N      | Y      | -    | L might contain R                                                                                                    | -           | compare leaf hashes of L to the single hash of R in lazy-seq      | L, R    | Y     |
| L is prefix of R   | N      | N      | -    | L might contain R, child nodes of L which are not R are missing from remote, if prefix or equal to R we need to diff | -           | compare children of L to a sequence containing the single child R | L, R    | Y     |
| R is prefix of L   | -      | Y      | -    | R is new to local                                                                                                    | new R       | -                                                                 | R       | Y     |
| R is prefix of L   | Y      | N      | -    | R might contain L                                                                                                    | -           | compare leaf hashes of R to the single hash of L in lazy-seq      | L, R    | Y     |
| R is prefix of L   | N      | N      | -    | R might contain L, child nodes of R which are not L are new to local, if prefix or equal to L we need to diff        | -           | compare children of R to a sequence containing the single child L | L, R    | Y     |
| L == R             | Y      | Y      | same | same key + hash, skip                                                                                                | -           | -                                                                 | L, R    | Y     |
| L == R             | Y      | Y      | diff | same key, different hash                                                                                             | different L | -                                                                 | L, R    | Y     |
| L == R             | Y      | N      | -    | equivalent to R prefix of L (with L being empty key) - R might contain L                                             | -           | compare leaf hashes of R to the single hash of L in lazy-seq      | L, R    | Y     |
| L == R             | N      | Y      | -    | equivalent to L prefix of R (with R being empty key) - L might contain R                                             | -           | compare leaf hashes of L to the single hash of R in lazy-seq      | L, R    | Y     |
| L == R             | N      | N      | same | same prefix + hash, skip                                                                                             | -           | -                                                                 | L, R    | Y     |
| L == R             | N      | N      | diff | same prefix, different hash                                                                                          | -           | compare children of L to children of R                            | L, R    | Y     |
| L < R (not prefix) | Y      | -      | -    | same as when R is null                                                                                               | missing L   | -                                                                 | L       | Y     |
| L < R (not prefix) | N      | -      | -    | same as when R is null                                                                                               | -           | request leaf hashes of L to mark as missing                       | L       | Y     |
| L > R (not prefix) | -      | Y      | -    | same as when L is null                                                                                               | new R       | -                                                                 | R       | Y     |
| L > R (not prefix) | -      | N      | -    | same as when L is null                                                                                               | -           | request leaf hashes of R to mark as new                           | R       | Y     |
